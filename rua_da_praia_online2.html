<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rua da Praia – p5.js + otimizado</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
</head>

<body>
  <div id="wrap"></div>
  <script>
    const W = 768, H = 1156;
    let TILE_SIZE = 7, BAND = 80, WAVELEN = 210, NUM_ROWS = 8;
    let AMP_BASE = 6, AMP_TARGET = 70;
    let gx = (W / 4) * 3, gy = W / 4, radius = 75;
    let seed = 42;

    const totalFrames = 300;
    let t = 0;
    let speed = 1 / totalFrames;

    let gridData = []; // pré-calculado
    let bgLayer;       // buffer fixo (fundo com noise)

    function setup() {
      const cnv = createCanvas(W, H, P2D);
      cnv.parent('wrap');
      pixelDensity(1);
      frameRate(30);

      randomSeed(seed);
      noiseSeed(seed);

      // --- Pré-calcula mosaico (pedras) ---
      const jitter = TILE_SIZE * 0.40;
      for (let gy = 0; gy < H + TILE_SIZE; gy += TILE_SIZE) {
        for (let gx = 0; gx < W + TILE_SIZE; gx += TILE_SIZE) {
          const jx = (noise(gx * 0.03, gy * 0.03, 0.1) - 0.5) * 2 * jitter;
          const jy = (noise(gx * 0.03, gy * 0.03, 7.7) - 0.5) * 2 * jitter;
          const x = gx + jx;
          const y = gy + jy;

          const r = random(0.45, 0.9) * TILE_SIZE;

          // cor individual para cada pedra
          const base = 220 + random(-10, 30);
          const c = color(base);

          const n = floor(random(4, 8));
          let verts = [];
          for (let i = 0; i < n; i++) {
            const a = (TWO_PI * i) / n + random(-0.5, 0.15);
            const rr = r * (0.75 + random(-0.15, 0.2));
            verts.push([cos(a) * rr, sin(a) * rr]);
          }
          gridData.push({ x, y, verts, colorData: c });
        }
      }

      // --- Cria camada fixa apenas com noise (fundo) ---
      bgLayer = createGraphics(W, H);
      bgLayer.pixelDensity(1);
      bgLayer.loadPixels();
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          let idx = 4 * (x + y * W); // correto
          let n = noise(x * 0.01, y * 0.01); // frequência suave
          let bright = floor(n * 255); // tons de cinza
          bgLayer.pixels[idx + 0] = bright;
          bgLayer.pixels[idx + 1] = bright;
          bgLayer.pixels[idx + 2] = bright;
          bgLayer.pixels[idx + 3] = 255;
        }
      }
      bgLayer.updatePixels();
    }

    function draw() {
      t += speed;
      if (t > 1) t -= 1;

      const waveHeight = H * easeLoop(t);
      const slabY0 = H - waveHeight;
      const rowGap = (waveHeight > 0) ? (waveHeight / NUM_ROWS - 1) : 0;
      const AMP = constrain(lerp(AMP_BASE, AMP_TARGET, easeLoop(t)), 0, Math.max(0, 0.6 * rowGap - BAND * 0.5));

      // --- Fundo com noise ---
      image(bgLayer, 0, 0);

      // --- Pedras (mosaico) ---
      drawMosaicWaves(AMP, rowGap, slabY0);

      // --- Bueiros ---
      for (let i = 1; i < 4; i++) {
        drawBueiro(100, 100 + (i * 300), 70);
      }

      // --- Guarda-sol ---
      guarda_sol();
    }

    // --- Funções auxiliares ---
    function easeLoop(u) {
      if (u < 0.50) { let p = u / 0.50; return easeOutQuad(p); }
      else { let p = (u - 0.51) / 0.50; return 1 - easeInQuad(p); }
    }
    function easeOutQuad(x) { return 1 - (1 - x) * (1 - x); }
    function easeInQuad(x) { return x * x; }

    function inBlackBand(x, y, AMP, rowGap, slabY0) {
      if (rowGap <= 0 || y < slabY0) return false;
      const k = TWO_PI / WAVELEN;
      const yy = y - slabY0;
      const rowIndex = Math.floor(yy / rowGap);
      const baseY = slabY0 + (rowIndex + 0.5) * rowGap;
      const angle = k * x;
      const s = Math.sin(angle);
      const shaped = Math.sign(s) * Math.pow(Math.abs(s), 0.5);
      const center = baseY + AMP * shaped;
      const thicknessFactor = 0.4 + 0.6 * Math.abs(shaped);
      const localBand = BAND * thicknessFactor;
      return Math.abs(y - center) <= localBand * 0.44;
    }

    function drawMosaicWaves(AMP, rowGap, slabY0) {
      const outerBorderWidth = 22;
      const margin = 40;

      for (let g of gridData) {
        const { x, y, verts } = g;

        let colFill, colStroke, sw;
        let isOuterBorder = (x < outerBorderWidth + 2) || (x > W - outerBorderWidth - 2);
        let isWaveX = (x > margin && x < W - margin + 2);

        if (isOuterBorder) {
          colFill = color(30);
          colStroke = color(30); sw = 1;
        } else if (y < slabY0) {
          colFill = g.colorData;
          colStroke = color(60); sw = 0.5;
        } else {
          let isBlack = isWaveX && inBlackBand(x, y, AMP, rowGap, slabY0);
          if (isBlack) {
            colFill = color(30);
            colStroke = color(30); sw = 1;
          } else {
            colFill = g.colorData;
            colStroke = color(60); sw = 0.5;
          }
        }

        fill(colFill);
        stroke(colStroke);
        strokeWeight(sw);
        beginShape();
        for (let v of verts) vertex(x + v[0], y + v[1]);
        endShape(CLOSE);
      }
    }

    function guarda_sol() {
            push();
            noStroke();
            fill(0, 0, 0, 3);
            translate(gx, gy);
            /*
            for (let a = 0; a < 1; a++) {
                ellipse(-80, 0, radius * 3, radius*2,2);
            }
            */
            stroke(110); strokeWeight(0.5);
            let cores = [130, 150, 170, 100]; let segments = 16;

            for (let i = 0; i < segments; i++) {
                fill(cores[i % cores.length]);
                let angle1 = (TWO_PI / segments) * i;
                let angle2 = (TWO_PI / segments) * (i + 1);
                beginShape();
                vertex(0, 0);
                vertex(cos(angle1) * radius, sin(angle1) * radius);
                vertex(cos(angle2) * radius, sin(angle2) * radius);
                endShape(CLOSE);
            }


            noStroke();
            fill(0, 0, 0, 100);
            for (a = 0; a < 1; a++) {
                arc(0, 0, radius * 2, radius * 2, PI / 2, -PI / 2, PIE);
            }
            pop();
        }

    function drawBueiro(x, y, r) {
      push();
      translate(x, y);
      noStroke();
      fill(30, 30, 30, 5);
      for (i = 0; i < 4; i++) {
        ellipse(0, 0, r + (i * 4), r + (i * 4));
      }

      fill(60);
      ellipse(0, 0, r, r);

      let numSectors = 16;
      stroke(100);
      for (let i = 0; i < numSectors; i++) {
        let angle = TWO_PI * i / numSectors;
        line(0, 0, cos(angle) * r / 2, sin(angle) * r / 2);
      }

      noFill();
      stroke(80);
      for (let i = 1; i <= 5; i++) {
        ellipse(0, 0, (r / 5) * i, (r / 5) * i);
      }

      let screwDist = r * 0.45;
      let screwSize = 8;
      fill(45);
      noStroke();
      ellipse(screwDist, 0, screwSize);
      ellipse(-screwDist, 0, screwSize);
      ellipse(0, screwDist, screwSize);
      ellipse(0, -screwDist, screwSize);

      pop();
    }
  </script>
</body>

</html>
